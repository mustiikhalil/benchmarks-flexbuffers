// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

#if canImport(Common)
import Common
#endif

import FlatBuffers

public struct Geo_Coordinate: NativeStruct, FlatbuffersVectorInitializable, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }

  private var _latitude: Double
  private var _longitude: Double

  public init(_ bb: ByteBuffer, o: Int32) {
    self = bb.read(def: Self.self, position: Int(o))
  }

  public init(latitude: Double, longitude: Double) {
    _latitude = latitude
    _longitude = longitude
  }

  public init() {
    _latitude = 0.0
    _longitude = 0.0
  }

  public var latitude: Double { _latitude }
  public var longitude: Double { _longitude }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: Geo_Coordinate.self)
  }
}

public struct Geo_Coordinate_Mutable: FlatBufferStruct, FlatbuffersVectorInitializable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  public var latitude: Double { return _accessor.readBuffer(of: Double.self, at: 0) }
  public var longitude: Double { return _accessor.readBuffer(of: Double.self, at: 8) }
}

public struct Geo_FeatureCollection: FlatBufferTable, FlatbuffersVectorInitializable, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case type = 4
    case features = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var type: String? { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var typeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.type.v) }
  public var features: FlatbufferVector<Geo_Feature> { return _accessor.vector(at: VTOFFSET.features.v, byteSize: 4) }
  public static func startFeatureCollection(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(type: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: type, at: VTOFFSET.type.p) }
  public static func addVectorOf(features: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: features, at: VTOFFSET.features.p) }
  public static func endFeatureCollection(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFeatureCollection(
    _ fbb: inout FlatBufferBuilder,
    typeOffset type: Offset = Offset(),
    featuresVectorOffset features: Offset = Offset()
  ) -> Offset {
    let __start = Geo_FeatureCollection.startFeatureCollection(&fbb)
    Geo_FeatureCollection.add(type: type, &fbb)
    Geo_FeatureCollection.addVectorOf(features: features, &fbb)
    return Geo_FeatureCollection.endFeatureCollection(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.features.p, fieldName: "features", required: false, type: ForwardOffset<Vector<ForwardOffset<Geo_Feature>, Geo_Feature>>.self)
    _v.finish()
  }
}

public struct Geo_Feature: FlatBufferTable, FlatbuffersVectorInitializable, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case type = 4
    case properties = 6
    case geometry = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var type: String? { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var typeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.type.v) }
  public var properties: FlatbufferVector<Geo_PropertyEntry> { return _accessor.vector(at: VTOFFSET.properties.v, byteSize: 4) }
  public var geometry: Geo_Geometry? { let o = _accessor.offset(VTOFFSET.geometry.v); return o == 0 ? nil : Geo_Geometry(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public static func startFeature(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(type: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: type, at: VTOFFSET.type.p) }
  public static func addVectorOf(properties: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: properties, at: VTOFFSET.properties.p) }
  public static func add(geometry: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: geometry, at: VTOFFSET.geometry.p) }
  public static func endFeature(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFeature(
    _ fbb: inout FlatBufferBuilder,
    typeOffset type: Offset = Offset(),
    propertiesVectorOffset properties: Offset = Offset(),
    geometryOffset geometry: Offset = Offset()
  ) -> Offset {
    let __start = Geo_Feature.startFeature(&fbb)
    Geo_Feature.add(type: type, &fbb)
    Geo_Feature.addVectorOf(properties: properties, &fbb)
    Geo_Feature.add(geometry: geometry, &fbb)
    return Geo_Feature.endFeature(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.properties.p, fieldName: "properties", required: false, type: ForwardOffset<Vector<ForwardOffset<Geo_PropertyEntry>, Geo_PropertyEntry>>.self)
    try _v.visit(field: VTOFFSET.geometry.p, fieldName: "geometry", required: false, type: ForwardOffset<Geo_Geometry>.self)
    _v.finish()
  }
}

public struct Geo_PropertyEntry: FlatBufferTable, FlatbuffersVectorInitializable, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case key = 4
    case value = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var key: String? { let o = _accessor.offset(VTOFFSET.key.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var keySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.key.v) }
  public var value: String? { let o = _accessor.offset(VTOFFSET.value.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var valueSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.value.v) }
  public static func startPropertyEntry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(key: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: key, at: VTOFFSET.key.p) }
  public static func add(value: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: value, at: VTOFFSET.value.p) }
  public static func endPropertyEntry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPropertyEntry(
    _ fbb: inout FlatBufferBuilder,
    keyOffset key: Offset = Offset(),
    valueOffset value: Offset = Offset()
  ) -> Offset {
    let __start = Geo_PropertyEntry.startPropertyEntry(&fbb)
    Geo_PropertyEntry.add(key: key, &fbb)
    Geo_PropertyEntry.add(value: value, &fbb)
    return Geo_PropertyEntry.endPropertyEntry(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.key.p, fieldName: "key", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.value.p, fieldName: "value", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct Geo_Geometry: FlatBufferTable, FlatbuffersVectorInitializable, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case type = 4
    case coordinates = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var type: String? { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var typeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.type.v) }
  public var coordinates: FlatbufferVector<Geo_CoordinateList> { return _accessor.vector(at: VTOFFSET.coordinates.v, byteSize: 4) }
  public static func startGeometry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(type: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: type, at: VTOFFSET.type.p) }
  public static func addVectorOf(coordinates: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: coordinates, at: VTOFFSET.coordinates.p) }
  public static func endGeometry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGeometry(
    _ fbb: inout FlatBufferBuilder,
    typeOffset type: Offset = Offset(),
    coordinatesVectorOffset coordinates: Offset = Offset()
  ) -> Offset {
    let __start = Geo_Geometry.startGeometry(&fbb)
    Geo_Geometry.add(type: type, &fbb)
    Geo_Geometry.addVectorOf(coordinates: coordinates, &fbb)
    return Geo_Geometry.endGeometry(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.coordinates.p, fieldName: "coordinates", required: false, type: ForwardOffset<Vector<ForwardOffset<Geo_CoordinateList>, Geo_CoordinateList>>.self)
    _v.finish()
  }
}

public struct Geo_CoordinateList: FlatBufferTable, FlatbuffersVectorInitializable, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case coords = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var coords: FlatbufferVector<Geo_Coordinate> { return _accessor.vector(at: VTOFFSET.coords.v, byteSize: 16) }
  public var mutableCoords: FlatbufferVector<Geo_Coordinate_Mutable> { return _accessor.vector(at: VTOFFSET.coords.v, byteSize: 16) }
  public func withUnsafePointerToCoords<T>(_ body: (UnsafeRawBufferPointer, Int) throws -> T) rethrows -> T? { return try _accessor.withUnsafePointerToSlice(at: VTOFFSET.coords.v, body: body) }
  public static func startCoordinateList(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(coords: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: coords, at: VTOFFSET.coords.p) }
  public static func startVectorOfCoords(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<Geo_Coordinate>.size, elementSize: MemoryLayout<Geo_Coordinate>.alignment)
  }
  public static func endCoordinateList(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCoordinateList(
    _ fbb: inout FlatBufferBuilder,
    coordsVectorOffset coords: Offset = Offset()
  ) -> Offset {
    let __start = Geo_CoordinateList.startCoordinateList(&fbb)
    Geo_CoordinateList.addVectorOf(coords: coords, &fbb)
    return Geo_CoordinateList.endCoordinateList(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.coords.p, fieldName: "coords", required: false, type: ForwardOffset<Vector<Geo_Coordinate, Geo_Coordinate>>.self)
    _v.finish()
  }
}

